<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
<title>Something Given</title>
<!-- css file-->
<link rel="stylesheet" type="text/css" href="stylesheet.css">
<!--Swiper-->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.5.0/css/swiper.min.css">
<!-- paper js -->
<script type="text/javascript" src="paper-full.min.js"></script>
<!-- orientation script -->
<script type="text/javascript" src="orientation.js"></script>
<!-- rotating squares--
<script type="text/paperscript" src="square.js" canvas="myCanvas3"></script>
<!--bubble interaction--
<script type="text/paperscript" src="bubbles.js" canvas="myCanvas2"></script>
<!--<script type="text/paperscript" src="tadpoles.js" canvas="myCanvas4"></script>-->


</head>
<body>
  <!-- Slider main container -->
  <div id="hi" class="swiper-container">
  <div class="swiper-wrapper">
    <div id="0" class="swiper-slide">
      <canvas id="myCanvas4"></canvas>
      <!--<div>

        <div class="inner-text">You are connecting to Something Given</div>
        <div class="inner-text">
        Please follow directions</div>
        <div class="inner-text">
        To move on please swipe the page</div>
      </div>-->
    </div>
    <div id="s1" class="swiper-slide">
        <div>
          <div class="inner-text">Beside you is a wire case attached to the wall</div>
          <div class="inner-text">
          Here you can prepare your mobile companion for the pilgrimage ahead</div>
          <div class="inner-text">(swipe)</div>
        </div>
    </div>
    <div id="s2" class="swiper-slide">
      <div>
        <div class="inner-text">There are some chargers</div>
        <div class="inner-text">How long are you willing to stand here to avoid digital blackout? </div>
        <div id="battery" class="inner-text"></div>

        <div class="inner-text">(swipe)</div>
      </div>
    </div>
    <div id="s3" class="swiper-slide">
      <div>
        <div class="inner-text">When was the last time you cleansed this screen?</div>
        <div class="inner-text">Dusted away debris from itâ€™s orifices</div>
        <div class="inner-text">Where has your mechanical partner been with you?</div>
      </div>
    </div>
    <div id="s4" class="swiper-slide">
      <div>
        <div class="inner-text">You can decorate if you wish</div>
        <div class="inner-text">Do you think it understands the sentiment of these little faces just like you?
        </div>
      </div>
    </div>
    <div id= "s5" class="swiper-slide">
      <div>
        <div class="inner-text">How much personalisation have you done?</div>
        <div class="inner-text">This is your confident through which you share, watch, work, socialise and play</div>
      </div>
    </div>
    <div id= "s6" class="swiper-slide">
      <div>
        <div class="inner-text">Listening, tracking, interpreting, predicting and transfers your personal world</div>
        <div class="inner-text">Creating a mishapen shadow</div>
    </div>
  </div>
    <div id= "s7" class="swiper-slide">
      <div>
        <div id="OS" class="inner-text"></div>
        <div class="inner-text"></div>
    </div>
    </div>
    <div id= "s8" class="swiper-slide">
      <div>
        <div class="inner-text">Whilst you browse do you ever think about what information is slipping through?</div>
        <div id="referrer" class="inner-text"></div>
        <div class="inner-text">Or do you never think about it?</div>
    </div>
    </div>

    <div id= "s9"  class="swiper-slide">
      <div>
        <div class="inner-text">Now I would like you to stand a apart from others</div>
        <div class="inner-text">This is an experience for you and your own mechanical assistant</div>
      </div>
    </div>
    <div "s10" class="swiper-slide">
      <div>
        <div class="inner-text">You've given substantial immaterial, untangible information away</div>
        <div class="inner-text">Small flicks of fingers and bumps in pockets.</div>
        <div class="inner-text">A tool we cease to acknowledge.</div>
    </div>
    </div>
    <div id="s11" class="swiper-slide">
      <div>
        <div class="inner-text">Stand facing the N on the floor</div>
        <div class="inner-text">Use the compass on the following screen to find South</div>
    </div>
    </div>
    <div id="s12" class="swiper-slide swiper-no-swiping">
      <p class="inner-text"></p>
    </div>
    <div id="s13" class="swiper-slide">
      <div>
        <div class="inner-text">Now circle your phone in the air</div>
        <div class="inner-text">(swipe when done)</div>
      </div>
    </div>
    <div id="s14" class="swiper-slide">
      <div>
        <div class="inner-text">Well done</div>
        <div class="inner-text">Your device is now calibrated</div>
      </div>

    </div>
    <div id="s15" class="swiper-slide">
      <div>
        <div class="inner-text">I want you to think of an emotional digital interchange you've had in the last month</div>
        <div class="inner-text">It can be loving, painful, regretful</div>
      </div>
    </div>
    <div id="s16" class="swiper-slide">
      <div>
        <div class="inner-text">Take as long as you need</div>
      </div>
    </div>
    <div id="s17" class="swiper-slide">
      <div>
        <div class="inner-text">On the next page you will be drawing whilst moving your device</div>
        <div class="inner-text">Draw the transfer of this intimate exchange to analysed data </div>
      </div>
    </div>
    <div id="s18" class="swiper-slide">
      <canvas id="myCanvas"></canvas>
    </div>
    <div id="s19" class="swiper-slide">
      <div>
        <div class="inner-text">This data leak does not just concern you</div>
        <div class="inner-text">Not just your human recipient </div>
        <div class="inner-text">Not just your human recipient </div>
      </div>
    </div>
    <div id="s20" class="swiper-slide">
      <canvas id="myCanvas2"></canvas>
    </div>
    <div id="s19" class="swiper-slide">

    </div>
    <div id="s20" class="swiper-slide">
      <canvas id="myCanvas3"></canvas>
    </div>

  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.5.0/js/swiper.min.js"></script>
<script type="text/javascript" src="orientation.js"></script>
<script>

//initialise globals
window.onload;
window.globals = {
  gx:0, gy:0, gz:0, gvx:0, gvy:0, canvasx: 0, canvasy: 0,
};

globals.canvasx = window.screen.width;
globals.canvasy = window.screen.height;
window.addEventListener("devicemotion", handleMotion, true);
  //initialise swiper
  var swiper = new Swiper('.swiper-container');
  // Get event data
  swiper.on( 'slideChange', function() {

    if (swiper.realIndex == 0) {

} else if (swiper.realIndex == 2) {


} else if (swiper.realIndex == 11) {
  window.addEventListener("deviceorientation", deviceCompassListener);
  swiper.allowSlidePrev = false;
} else if (swiper.realIndex == 13) {

  window.removeEventListener("deviceorientation", deviceCompassListener);
    window.addEventListener("devicemotion", handleMotion, true);
} else if (swiper.realIndex == 14){
  swiper.allowSlidePrev = true;
  document.body.style.backgroundImage = "repeating-radial-gradient(white, #cc5500 25%, white 50%)";
  window.addEventListener("deviceorientation", handleOrientation);
  window.removeEventListener("devicemotion", handleMotion, true);
} else if (swiper.realIndex == 19){
  window.addEventListener("devicemotion", handleMotion, true);
}
  });
</script>

<!-- Line animation script--
<script type="text/javascript" src="animations.js"></script>-->
<script type="text/paperscript" canvas="myCanvas4">
// Adapted from Flocking Processing example by Daniel Schiffman:
// http://processing.org/learning/topics/flocking.html

var Boid = Base.extend({
 initialize: function(position, maxSpeed, maxForce) {
   var strength = Math.random() * 0.5;
   this.acceleration = new Point();
   this.vector = Point.random() * 2 - 1;
   this.position = position.clone();
   this.radius = 30;
   this.maxSpeed = maxSpeed + strength;
   this.maxForce = maxForce + strength;
   this.amount = strength * 10 + 10;
   this.count = 0;
   this.createItems();
 },

 run: function(boids) {

   this.lastLoc = this.position.clone();
   if (!groupTogether) {
     this.flock(boids);
   } else {
     this.align(boids);
   }
   this.borders();
   this.update();
   this.calculateTail();
   this.moveHead();
 },

 calculateTail: function() {
   var segments = this.path.segments,
     shortSegments = this.shortPath.segments;
   var speed = this.vector.length;
   var pieceLength = 5 + speed / 3;
   var point = this.position;
   segments[0].point = shortSegments[0].point = point;
   // Chain goes the other way than the movement
   var lastVector = -this.vector;
   for (var i = 1; i < this.amount; i++) {
     var vector = segments[i].point - point;
     this.count += speed * 10;
     var wave = Math.sin((this.count + i * 3) / 300);
     var sway = lastVector.rotate(90).normalize(wave);
     point += lastVector.normalize(pieceLength) + sway;
     segments[i].point = point;
     if (i < 3)
       shortSegments[i].point = point;
     lastVector = vector;
   }
   this.path.smooth();
 },

 createItems: function() {

   this.head = new Shape.Ellipse({
     center: [0, 0],
     size: [13, 8],
     fillColor: 'black'
   });

   this.path = new Path({
     strokeColor: 'black',
     strokeWidth: 2,
     strokeCap: 'round'
   });
   for (var i = 0; i < this.amount; i++)
     this.path.add(new Point());

   this.shortPath = new Path({
     strokeColor: 'black',
     strokeWidth: 4,
     strokeCap: 'round'
   });
   for (var i = 0; i < Math.min(3, this.amount); i++)
     this.shortPath.add(new Point());
 },

 moveHead: function() {
   this.head.position = this.position;
   this.head.rotation = this.vector.angle;
 },

 // We accumulate a new acceleration each time based on three rules
 flock: function(boids) {
   var separation = this.separate(boids) * 3;
   var alignment = this.align(boids);
   var cohesion = this.cohesion(boids);
   this.acceleration += separation + alignment + cohesion;
 },

 update: function() {
   // Update velocity
   this.vector += this.acceleration;
   // Limit speed (vector#limit?)
   this.vector.length = Math.min(this.maxSpeed, this.vector.length);
   this.position += this.vector;
   // Reset acceleration to 0 each cycle
   this.acceleration = new Point();
 },

 seek: function(target) {
   this.acceleration += this.steer(target, false);
 },

 arrive: function(target) {
   this.acceleration += this.steer(target, true);
 },

 borders: function() {
   var vector = new Point();
   var position = this.position;
   var radius = this.radius;
   var size = view.size;
   if (position.x < -radius) vector.x = size.width + radius;
   if (position.y < -radius) vector.y = size.height + radius;
   if (position.x > size.width + radius) vector.x = -size.width -radius;
   if (position.y > size.height + radius) vector.y = -size.height -radius;
   if (!vector.isZero()) {
     this.position += vector;
     var segments = this.path.segments;
     for (var i = 0; i < this.amount; i++) {
       segments[i].point += vector;
     }
   }
 },

 // A method that calculates a steering vector towards a target
 // Takes a second argument, if true, it slows down as it approaches
 // the target
 steer: function(target, slowdown) {
   var steer,
     desired = target - this.position;
   var distance = desired.length;
   // Two options for desired vector magnitude
   // (1 -- based on distance, 2 -- maxSpeed)
   if (slowdown && distance < 100) {
     // This damping is somewhat arbitrary:
     desired.length = this.maxSpeed * (distance / 100);
   } else {
     desired.length = this.maxSpeed;
   }
   steer = desired - this.vector;
   steer.length = Math.min(this.maxForce, steer.length);
   return steer;
 },

 separate: function(boids) {
   var desiredSeperation = 60;
   var steer = new Point();
   var count = 0;
   // For every boid in the system, check if it's too close
   for (var i = 0, l = boids.length; i < l; i++) {
     var other = boids[i];
     var vector = this.position - other.position;
     var distance = vector.length;
     if (distance > 0 && distance < desiredSeperation) {
       // Calculate vector pointing away from neighbor
       steer += vector.normalize(1 / distance);
       count++;
     }
   }
   // Average -- divide by how many
   if (count > 0)
     steer /= count;
   if (!steer.isZero()) {
     // Implement Reynolds: Steering = Desired - Velocity
     steer.length = this.maxSpeed;
     steer -= this.vector;
     steer.length = Math.min(steer.length, this.maxForce);
   }
   return steer;
 },

 // Alignment
 // For every nearby boid in the system, calculate the average velocity
 align: function(boids) {
   var neighborDist = 25;
   var steer = new Point();
   var count = 0;
   for (var i = 0, l = boids.length; i < l; i++) {
     var other = boids[i];
     var distance = this.position.getDistance(other.position);
     if (distance > 0 && distance < neighborDist) {
       steer += other.vector;
       count++;
     }
   }

   if (count > 0)
     steer /= count;
   if (!steer.isZero()) {
     // Implement Reynolds: Steering = Desired - Velocity
     steer.length = this.maxSpeed;
     steer -= this.vector;
     steer.length = Math.min(steer.length, this.maxForce);
   }
   return steer;
 },

 // Cohesion
 // For the average location (i.e. center) of all nearby boids,
 // calculate steering vector towards that location
 cohesion: function(boids) {
   var neighborDist = 100;
   var sum = new Point();
   var count = 0;
   for (var i = 0, l = boids.length; i < l; i++) {
     var other = boids[i];
     var distance = this.position.getDistance(other.position);
     if (distance > 0 && distance < neighborDist) {
       sum += other.position; // Add location
       count++;
     }
   }
   if (count > 0) {
     sum /= count;
     // Steer towards the location
     return this.steer(sum, false);
   }
   return sum;
 }
});

var heartPath = new Path('M514.69629,624.70313c-7.10205,-27.02441 -17.2373,-52.39453 -30.40576,-76.10059c-13.17383,-23.70703 -38.65137,-60.52246 -76.44434,-110.45801c-27.71631,-36.64355 -44.78174,-59.89355 -51.19189,-69.74414c-10.5376,-16.02979 -18.15527,-30.74951 -22.84717,-44.14893c-4.69727,-13.39893 -7.04297,-26.97021 -7.04297,-40.71289c0,-25.42432 8.47119,-46.72559 25.42383,-63.90381c16.94775,-17.17871 37.90527,-25.76758 62.87354,-25.76758c25.19287,0 47.06885,8.93262 65.62158,26.79834c13.96826,13.28662 25.30615,33.10059 34.01318,59.4375c7.55859,-25.88037 18.20898,-45.57666 31.95215,-59.09424c19.00879,-18.32178 40.99707,-27.48535 65.96484,-27.48535c24.7373,0 45.69531,8.53564 62.87305,25.5957c17.17871,17.06592 25.76855,37.39551 25.76855,60.98389c0,20.61377 -5.04102,42.08691 -15.11719,64.41895c-10.08203,22.33203 -29.54687,51.59521 -58.40723,87.78271c-37.56738,47.41211 -64.93457,86.35352 -82.11328,116.8125c-13.51758,24.0498 -23.82422,49.24902 -30.9209,75.58594z');

var boids = [];
var groupTogether = false;

// Add the boids:
for (var i = 0; i < 30; i++) {
 var position = Point.random() * view.size;
 boids.push(new Boid(position, 10, 0.05));
}


function onFrame(event) {
 for (var i = 0, l = boids.length; i < l; i++) {
   if (groupTogether) {
     var length = ((i + event.count / 30) % l) / l * heartPath.length;
     var point = heartPath.getPointAt(length);
     if (point)
       boids[i].arrive(point);
   }
   boids[i].run(boids);
 }
 if (globals.gvy > 20){
   boids.push(new Boid(position, 10, 0.05))
 }


}

// Reposition the heart path whenever the window is resized:
function onResize(event) {
 heartPath.fitBounds(view.bounds);
 heartPath.scale(0.8);
}

function onMouseDown(event) {
 groupTogether = !groupTogether;
}

function onKeyDown(event) {
 if (event.key == 'space') {
   var layer = project.activeLayer;
   layer.selected = !layer.selected;
   return false;
 }
}

</script>

</body>
</html>
